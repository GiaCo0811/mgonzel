> > Linkeo:
> >
> > Un programa prog01 llama a un procedimiento proc() Describir como son los
> > mecanismos
> > de link y de transferencia de control en ejecución en el caso de:
> >   a) Enlace estático
> >  b) Enlace dinámico resuelto en tiempo de link-edición.
> >  c) Enlace dinámico resuelto en tiempo de ejecución.
> > ¿Qué pasa en cada caso si proc() es compartida?
> >
>
 a)  en enlace estatico el código de proc() está integrado al archivo ejecutable
 (forma parte de dicho archivo) y se carga en memoria al cargarse el programa
 y convertirse en proceso. Si me llevo este archivo a otra maquina con el mismo
 sistema operativo, anda aunque las versiones de las libraries
 (bibliotecas) sean distintas.
 Se crea compilando con  gcc -s (ver laboratorio)
 b) el procedimiento proc() se integra al ejecutable cuando se carga el
programa a la memoria (o cuando se lo llama por priemra vez, depende
del kernel y de la "ingenieria" de la biblioteca). Se sabe de que
biblioteca (library) se carga porque
en link-edicion se "resuelve" el nombre de la biblioteca. Para que
funcione en otra maquina
las versiones de las bibliotecas deben ser las mismas (o compatibles a nivel
de llamada, en general las mas modernas son compatibles con las
anteriores pero ...).
c) En tiempo de ejecucion el programa "decide" de que biblioteca cargar y debe
ubicar la biblioteca (dlopen() ) y el procedimiento dentro de la
biblioteca (dlsym()).
Ver detalle en el laboratorio donde hay un ejemplo de cada tipo.

Si proc es compartido, en la version de carga dinamica con resolucion en
link-edicion se usa la copia que esta en la memoria si hay alguna.

>
> > Desde el punto de vista del programador, ¿cuales son las diferencias entre
> > el load time
> >  dynamic linking y run time dynamic linking?. ¿Y desde el punto de vista del
> > Sistema
> > Operativo?
> >

Fijate en el laboratorio de libraries y linker. En el primer caso
llama al procedimiento
y se asegura que la biblioteca este disponible al cargar el programa en memoria.
En el segundo caso debe estar disponible al ejecutarse.


> > ¿Cuáles son las diferencias entre el run time dynamic linking en un lenguaje
> > procedural y
> > la carga dinámica de clases en un ambiente de objetos?.
> >

En procedural se usan las rutinas de dlopen, dlsym, etc para ubicar la
biblioteca y el procedimiento.
En objetos-Java, toda carga es dinamica y las clases deben estar
disponibles "on demand" cuando se las necesite.
El programador no se da cuenta de eso (a menos que quiera).
En el HelloWorldGenerator de java un programa crea una clase en forma
dinamica escribiendo un archivo fuente, llamado al compilador y
despues llama a la
clase compilada ... que no existia al iniciar el programa.

> > ----
> >
> > Describa el funcionamiento de la system call exec() ¿Qué instrucción se
> > ejecuta a
> >  continuación de un exec() ?
> >

exec( ) cambia el codigo (txt) de este proceso por el contenido de un
archivo ejecutable. Si el
ecxec() tiene exito la proxima instruccion es la primera del archivo
ejecutable. No vuelve al programa que
hizo el exec() no confundir con system() que corre el programa como
subrutina. Ver el Laboratorio de
Procesos y Threads

> > La open-file-table (oft) se usa para mantener información acerca de los
> > archivos abiertos. En
> > la clase se explicó una implementación donde hay una oft global.
> > ¿Qué inconvenientes traería si hubiera una por cada proceso?

No habria forma de saber si un archivo esta siendo usado por otro
proceso. En caso de estar siendo escrito por mas de un proceso, el
resultado es desastroso.

> >  Discuta qué estructuras adicionales precisa y como como funcionaría el
> > open() en un diseño
> > con una oft por proceso.

Haria falta una estructura que indique que archivo tiene abierto cada
proceso y en que
modo (read, write o r-w) que el open() consultaria. En esta estructura
se guardarian los
locks para impedir accesos simultáneos accidentales.

> >
> >
> > Describa paso a paso el desarrollo de una library call como fwrite().
> > Indique en que
> > momento ocurre la software trap y en que momento ocurre la interrupción de
> > I/O. ¿Es
> >  necesario que quede bloqueado el proceso hasta que termina la operación de
> > I/O sobre el
> > medio físico? (se trata de una operación de salida con buffers de usuario
> > implementados
> > por las bibliotecas del lenguaje de programación, printf y/o el ostream&
> > operator<<
> >  pueden considerarse basadas en fwrite ).

la library call hace un prologo, llama a la system call (a veces, en
el caso de fwrite es asi)
y despues de hacer el system call hace un epilogo.
No es preciso bloquear al proceso una vez que los buffers estan
cargados, a menos que quiera
volver a leer lo que acabo de escribir. El prologo y el epilogo manejan  flags
para solucionar esto. En el caso nombrado de c y c++ la que se encarga de eso
es la glibc (biblioteca c que forma ademas parte del unix).

> >
> >
> > En un sistema que admite rutinas compartidas y areas separadas de datos y
> > código se
> > implementa el Working Set con estructuras que mantienen la dirección base de
> > una página
> >  y k páginas anteriores y k posteriores contiguas. (por ejemplo, con
> > direccionamiento de
> > 32 bits, 16 bits de número de página, k=0x10, la estructura con base en
> > 0xCA50 abarca
> > las páginas con direcciones virtuales desde 0xCA40 0000 hasta CA60 FFFF, o
> > sea 0x21
> >  (33) páginas)
> > Para este sistema responda Verdadero/Falso y justifique:
> >  a) Una página puede solamente estar en una única de estas estructuras, una
> > estructura
> >     solamente puede estar en un único working set.
> >   b) Un proceso solo puede tener una de estas estructuras en su working set.
> >

mas alla de los numeros con los que indico que el working set es un
espacio contiguo
ya que la definicion "conjunto de paginas recientemente usadas" puede
no ser contigua ...
a) si una rutina es compartida, la pagina donde esta el codigo puede
estar en mas
de un working set (no los datos que son propios de cada proceso). Por ejemplo,
dos procesos pueden estar haciendo un read () al mismo tiempo (sobre
el mismo o diferentes
archivos, no importa para este caso).
b) Un proceso puede tener varias de esas estructuras por distintas causas:
un ws de codigo y otro de datos (son areas de memoria separadas) o mas de un
thread por ejemplo.

> >
> > Describa paso a paso el desarrollo de una library call. Indique su
> > diferencia con una
> > system call. En ambos casos
> >  a) ¿Pasa siempre la CPU a modo protegido (supervisor, kernel, etc)?
> >   b) ¿Pasa siempre el Sistema Operativo a modo Kernel? ¿porqué? ¿porqué?
> >
> >
> >
Esta en los slides de introduccion. Lee bien la parte de las capas para no
confundir CPU con Sistema Operativo
a) una system call pasa siempre la CPU a modo protegido, una library
call puede no hacerlo
(por ejemplo al obtener el process id)
b) Siempre el sistema operativo pasa a modo Kernel (corren rutinas que estan
compiladas en el kernel y tiene acceso a partes de la memoria que el programa
no puede ver).
De todas formas, en algunos libros confunden estos dos modos para
simplificar,  asi que debo tener cuidado con las respuestas. Lo
improtante es que
hayan entnedido el modelo de capas de la introduccion.


> En una operación de read de disco, describa como son transformados los datos
> de
> entrada por las siguientes capas del software de I/O (device independent,
> device
> drivers, interrupt handler) por el hardware tanto en el caso de una operción
> buffered
> como unbuffered. Indique cuando el proceso queda bloqueado (si lo hace)
>
En un read. El software de I/O lee secotres de disco segun la
arquitectura de disco y el modo (PIO o DMA) de funcionamiento del
mismo. Para esta lectura el driver envia los comandos de I/O al
controlador (IDE). El controlador (generalmente un IDE, con bastante
inteligencia como apra mantener un cache en la controladora del disco)
prepara los datos y los transfiere a memoria (DMA) o los deja en el
registro de datos del dispositivo y el driver lo transfiere a memoria
(PIO). Cuando termina la transferencia se genera una interrupcion de
I/O (ya lso datos estan en el buffer del sistema).
El Interrupt handler mapea los buffers (o los copia, en algunas
implementaciones viejas)
al espacio de direccines del proceso que pidio la I/O.
El device independent software se encarga de desarmar los sectores de
disco y preparar los bloques de lectura segun lo que se haya pedido en
el read, guardand lo que le sobra para el proximo read.
Despues ya actuan las bibliotecas de I/O (glibc por ejemplo) que
invoco el proceso, saliendo del modo kernel y dejandole los datos al
programa (pone el codigo de condicion -errno- y el de retorno -cant de
bytes realmente leidos-)

>
>
> Un script que primero hace lo siguiente:
> export V_UNO="HOLA"
> V_DOS="QUE TAL"
>
> Luego corre este otro:
> 1 #! /bin/sh
> 2 echo -n "Proceso $$ "
> 3 echo -n "$V_UNO "
> 4 echo $V_DOS
>
> Se pide la ubicacion de las variables en la U_AREA.
> (no comprendo que seria la ubicacion de las variables, y como seria la
> U_AREA)
>

Son dos scripts. Hay que ver la secuencia de invocacion. En general
hay dos procesos
cada uno con us U_Area. Si el codigo que pusiste en segundo lugar se
llama por ejemplo scr.sh tenemos
en la U_AREA del shell original
V_UNO="HOLA"
V_DOS="QUE TAL"

al invocar a scr.sh, en la U_AREA del proceso recien creado, se copian
las variables
export-adas
V_UNO="HOLA"

V_DOS no tiene valor en este proceso
imprime entonces HOLA y nada mas.
Si scr.sh modifica V_UNO, la modificacion NO pasa al shell original
(las copias son
hacia adelante).

>
>
> Para que una interrupción sea atendida, se la debe habilitar; en general con
> una máscara.
> Explique si las siguientes system calls de un lenguaje como C producen o
> habilitan
> interrupciones, cuales, porqué lo hacen y que ocurre al producirse la
> interrupción
> habilitada:(2 puntos). Usar la hoja adjunta y los tipos de interrupciones
> ahí propuestos.
> a) read(...) b) write(...) c) getpid(...) d)mkdir( )
> (Tiene un cuadro de las siguientes entradas.. Produce, Habilita, ¿Qué se
> hace con la int. habilitada? )
read habilitra una interrupcion de I/O para cuando termina la lectura
(ver respuesta anterior). el proceso se bloquea hasta terminar el
read.
write habilita I/O cundo termine la transferencia. EL proceso no tiene
porque bloquearse (al menos hasta tratar de leer lo escrito)
getpid no produce ninguna interrupcion ni habilita ninguna.
mkdir es un write.
read y write producen uan software trap (no se si estaba entre als
interrupciones
propuestas).

>
>
>
> Para cada afirmación. Indique si es verdadera o falsa y justifique:
>    b) En un Sistema Operativo Orientado a Objetos, la Herencia y el
> Polimorfismo permiten
>       la extensión dinámica del Sistema Operativo. (Además de justificar, dé
> un ejemplo)
>

Si. se puede manejar un dispositivo sin conocerlo con tal que este
implemente alguna
interface pre-definida. Con Herencia se pueden ir agrupando
funcionalidades. Las basicas (impresion B/W, bold e italic en un
nivel) y las avanzadas (colores, photo-ret, etc) en subclases o mas
propiamente interfaces que extiendan a la original. El dispo elige que
interface implementa y asi queda definida su funcionalidad.

> Describa un esquema de planificación (scheduling) adecuado para la
> reproducción de un
> archivo multimedial.
> (Pense en EDF por ejemplo)

Exacto. EDF o rate monotonic son una respuesta muy buena a la pregunta.

> ¿Que conviene hacer si no llega a descomprimr un cuadro, detiene la
> reproducción hasta que esté listo o lo descarta? ¿Qué hace el esquema de
> planificación que
> Ud eligió?
Lo que conviene hacer es descartar el cuadro si es un B (el ojo
integra esos saltos y
no se nota) Si es un P o un I se necesita descomprimirlo para poder
trabajar los sigueintes. Ahi conviene congelar la imagen. Si se
descarta se van formando unos cuadritos que van arruinando toda la
secuencia hasta el roximo frame I.

El esquem a de planificacion NO maneja esto. El soft de descomprension
debe preguntar de alguna forma por la carga de la maquina para saber
si "se juega" a descomrimir o no. Eso es que hace tan dificil mezclar
multimedia con otro tipo de
procesamiento (a menos que el tiempo que tarda la desompresion sea
despreciable por tener un procesador rapido, pero siempre aparecen
mayores resoluciones y  sigue el
juego del gato y del raton)

